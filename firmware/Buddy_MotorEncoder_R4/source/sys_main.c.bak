/** @file sys_main.c 
*   @brief Application main file
*   @date 9.Sep.2014
*   @version 04.01.00
*
*   This file contains an empty main function,
*   which can be used for the application.
*/

/* (c) Texas Instruments 2009-2014, All rights reserved. */

/* USER CODE BEGIN (0) */
//	HalCoGen Libraries
#include "sci.h"
#include "gio.h"
#include "eqep.h"
#include "pinmux.h"
#include "adc.h"
#include "het.h"
#include "sys_core.h"

//	User Libraries
#include "MotorStateMachine.h"
#include "dac_buddy.h"
/* USER CODE END */

/* Include Files */

#include "sys_common.h"

/* USER CODE BEGIN (1) */
#include "defines.h"
/* USER CODE END */

/** @fn void main(void)
*   @brief Application main function
*   @note This function is empty by default.
*
*   This function is called after startup.
*   The user can use this function to implement the application.
*/

/* USER CODE BEGIN (2) */
adcData_t adc_data[2];

void delay(int del)
{
	int i = del;
	unsigned int j = 0xFFFF;
	while(i != 0)
	{
		for(j = 0xFFFF; j !=0; j--)
		{

		}
		i--;
	}
}

/* USER CODE END */


void main(void)
{
/* USER CODE BEGIN (3) */
	_enable_IRQ();

	//	Initialize Modules
	muxInit();
	gioInit();
	sciInit();
	QEPInit();
	adcInit();
	hetInit();

	initDAC(&leftDAC);
	//initDAC(&rightDAC);

	//eqepDisableAllInterrupts(eqepREG1);
	//eqepEnableCapture(eqepREG1);

	//	Initialize Structures
	//LeftMotor.initMotor(&LeftMotor, 0, 1, 4);

	//Stuff for Sensors
	adcStartConversion(adcREG1,adcGROUP1);
	//pwmStart(hetRAM1, pwm0);
	//pwmSetDuty(hetRAM1, pwm0, 50);
	//

	//RANDOM CRAP FROM EXAMPLE
	//eqepClearAllInterruptFlags (eqepREG1);
	//eqepSetMaxPosnCount (eqepREG1, 0xFFFFFFFF);
	//eqepEnableInterrupt (eqepREG1, QEINT_Pco);

	// PreScalers for eQEP
	eqepSetCapturePrescale(eqepREG1, QCAPCTL_Ccps_Capture_Div_32);
	eqepSetUnitPosnPrescale(eqepREG1, QCAPCTL_Upps_Div_64_Prescale);

	eqepEnableUnitTimer(eqepREG1);	/* Enable Unit Timer. */
	eqepEnableCounter(eqepREG1);	/* Enable Position Counter */
	eqepEnableCapture(eqepREG1);	/* Enable capture timer and capture period latch. */

	gioToggleBit( gioPORTA, SW_ENABLE); // ENABLES
	sciReceive( scilinREG, 1, (unsigned char *)&command[0]);

	while(1)
	{
		delay(100);
		sendDAC(&leftDAC, 0, (unsigned char)(255*2.6/3.3));
		//sciSendByte(scilinREG, 'a');*/

		/* Status flag is set to indicate that a new value is latched in the QCPRD register. */
		if((eqepREG1->QEPSTS & 0x80U) !=0U)
		{
			/* Elapsed time between unit position events */
			deltaT = eqepREG1->QCPRD;

			/* Calculate Velocity from deltaT and the value of the unit position. */
			current_speed = (float)eqepREG1->QPOSCNT/(float)deltaT;

			/* Clear the Status flag. */
			eqepREG1->QEPSTS |= 0x80U;
		}


		// ADC Stuff
		while((adcIsConversionComplete(adcREG1,adcGROUP1))==0);
		/*ch_count = */adcGetData(adcREG1, adcGROUP1,&adc_data[0]);
		sciSend(scilinREG, 2, (uint8*)&adc_data[1].value);
	}
/* USER CODE END */
}

/* USER CODE BEGIN (4) */
/* USER CODE END */
